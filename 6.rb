# マッチしたら文字列の開始位置が、そうでなければnilがかえる　条件分岐で主に使用
if '123-1234' =~ /\d{3}-\d{4}/
  p 'マッチしました'
else
  p 'マッチしませんでした'
end

p '123-1234'.match(/\d{3}-\d{4}/).class

# キャプチャ　合致するものがなかったらnilが返る　代入と条件分岐を同時に行うこともある
text = '私の誕生日は1999年9月29日です'
if arr = /(\d+)年(\d+)月(\d+)日/.match(text)
  p arr
else
  p 'nilだよ'
end
p arr[1]
p arr[2]
p arr[3]

# 名前付きキャプチャ　=~演算子を使ったらそのままローカル変数になってくれる（左辺が正規表現じゃないとダメ（変数に入れた正規表現もダメ））
arr2 = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
p arr2['year']

text = '私の誕生日は1999年9月29日です'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  p year, month, day
else
  p 'nilだよ'
end

# 組み込み変数（基本は上記を使うべき）
p $&, $1

# scan
p '1997年9月19日 2000年8月29日'.scan(/\d+年\d+月\d+日/)
# [],slice
p '1997年9月19日 2000年8月29日'[/\d+年\d+月\d+日/]
# split
p '1997年9月19日 2000年8月29日,2000年8月2日'.split(/,| /)
# gsub(第二引数にはブロックや八種も使用可能)
p '1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/,| /, ':')
p '1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/,| /) {|a| a == ',' ? ':' : '&'}
'1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/(\d+)年(\d+)月(\d+)日/) do
  p "#{$1}-#{$2}-#{$3}"
end
'1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/) do
  p "#{$~[:year]}-#{$~[:month]}-#{$~[:day]}"
end
