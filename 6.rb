# マッチしたら文字列の開始位置が、そうでなければnilがかえる　条件分岐で主に使用
if '123-1234' =~ /\d{3}-\d{4}/
  p 'マッチしました'
else
  p 'マッチしませんでした'
end

p '123-1234'.match(/\d{3}-\d{4}/).class

# キャプチャ　合致するものがなかったらnilが返る　代入と条件分岐を同時に行うこともある
text = '私の誕生日は1999年9月29日です'
if arr = /(\d+)年(\d+)月(\d+)日/.match(text)
  p arr
else
  p 'nilだよ'
end
p arr[1]
p arr[2]
p arr[3]

# 名前付きキャプチャ　=~演算子を使ったらそのままローカル変数になってくれる（左辺が正規表現じゃないとダメ（変数に入れた正規表現もダメ））
arr2 = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
p arr2['year']

text = '私の誕生日は1999年9月29日です'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  p year, month, day
else
  p 'nilだよ'
end

# 組み込み変数とRegexp.last_match（基本は上記を使うべき）
p $&, $1
p Regexp.last_match, Regexp.last_match(1)

# scan
p '1997年9月19日 2000年8月29日'.scan(/\d+年\d+月\d+日/)
# [],slice
p '1997年9月19日 2000年8月29日'[/\d+年\d+月\d+日/]
# split
p '1997年9月19日 2000年8月29日,2000年8月2日'.split(/,| /)
# gsub(第二引数にはブロックや八種も使用可能)
p '1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/,| /, ':')
p '1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/,| /) {|a| a == ',' ? ':' : '&'}
'1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/(\d+)年(\d+)月(\d+)日/) do
  p "#{$1}-#{$2}-#{$3}"
end
'1997年9月19日 2000年8月29日,2000年8月2日'.gsub(/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/) do
  p "#{$~[:year]}-#{$~[:month]}-#{$~[:day]}"
end

# もっと詳しく
# //じゃなくてこれでもいい　\でエスケープしなくてもいい
# %r!https://example/com!

# when分でも使える
text = '000-0000'
case text
when /\d{3}-\d{4}/
  p "#{$&}は郵便番号"
when /\d{3}-\d{4}-\d{4}/
  p "#{$&}は携帯電話番号"
when /\d{3}-\d{3}-\d{4}/
  p "#{$&}は家の電話番号"
end

# 正規表現のオプション　iをつけると大文字小文字を区別しなくなる
p 'HELLO' =~ /hello/i
p 'HELLO' =~ /hello/
# xをつけたらコメントをつけられるし改行が無視される
regexp = /
\d{3} #郵便番号の先頭
-
\d{4} #末尾
/x
p regexp =~ '123-1234'

# match?メソッドは組み込み変数を置き換えない
p /\d{3}-\d{4}/.match?('111-1111')
p $~
